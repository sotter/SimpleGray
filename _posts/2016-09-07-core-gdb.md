---
layout: post
title: 记录一次core分析的过程
category: default
---

***先看堆栈段***

```
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib64/libthread_db.so.1".
Core was generated by `./access_server'.
Program terminated with signal SIGABRT, Aborted.
#0  0x0000003062c32625 in raise () from /lib64/libc.so.6
[Current thread is 1 (Thread 0x7f705d3ff700 (LWP 6422))]

#0  0x0000003062c32625 in raise () from /lib64/libc.so.6
#1  0x0000003062c33e05 in abort () from /lib64/libc.so.6
#2  0x0000003062c2b74e in __assert_fail_base () from /lib64/libc.so.6
#3  0x0000003062c2b810 in __assert_fail () from /lib64/libc.so.6
#4  0x0000000000b83fa5 in folly::fbvector<std::shared_ptr<IOThreadConnManager>, std::allocator<std::shared_ptr<IOThreadConnManager> > >::operator[] (this=0x7f7064488160, n=19)
    at /opt/im-cloud-server-thirdparty/linux/include/folly/FBVector.h:1033
#5  0x0000000000bfd26f in IOThreadPoolConnManager::DispatchIOBufByConnID (this=0x7f7064488150, conn_id=81604399688, data=...) at /home/yongxue/im-cloud-server/baselib/net/io_thread_pool_manager.cc:274
#6  0x0000000000c0d9f7 in ServiceRouterManager::DispatchIOBuf (this=0x7f706450de30, conn_id=81604399688, data=...) at /home/yongxue/im-cloud-server/baselib/net/service_router_manager.cc:79
#7  0x0000000000ca5a07 in SendPduData (conn_id=81604399688, boxed=...) at /home/yongxue/im-cloud-server/baselib/message_util/message_handler_util.cc:64
#8  0x0000000000ca5c68 in SendClientPduData (conn_id=81604399688, boxed=...) at /home/yongxue/im-cloud-server/baselib/message_util/message_handler_util.cc:85
#9  0x0000000000b8ac67 in impdu::CImPduRawDataHandler::DoHandle (this=0x7f705d3fe510, raw_boxed=...) at /home/yongxue/im-cloud-server/server/access_server/message_handler/im_pdu_raw_data_boxed_handler.cc:265
#10 0x0000000000b89dff in impdu::CImPduRawDataHandler::Execute (pipepline=0x7f705b4361e0, raw_pdu=0x7f705e5228f0) at /home/yongxue/im-cloud-server/server/access_server/message_handler/im_pdu_raw_data_boxed_handler.cc:131
#11 0x0000000000cdd01a in impdu::MessageHandlerFactory::DispatchMessageHandler (pipepline=0x7f705b4361e0, pdu=0x7f705e5228f0) at /home/yongxue/im-cloud-server/baselib/message_util/message_handler.cc:66
#12 0x0000000000cdb6f2 in IMConnHandler::read (this=0x7f705b43e0c0, ctx=0x7f705b425190, msg=...) at /home/yongxue/im-cloud-server/baselib/net/im_conn_handler.cc:107

```
第一步可以看到不是段错误导致的，而是进程到了系统触发的SIGABRT信号退出；
再看堆栈段发现了__assert_fail， 说明是顶层报了assert触发的；


再看堆栈段4，初步怀疑是数组下标溢出，验证下看看：

查看fbvector的源码：
```cpp
  reference operator[](size_type n) {
    assert(n < size());  //问题就是出在这里；
    return impl_.b_[n];
  }
```

继续查看size()的实现：
```cpp
  size_type size() const noexcept {
    return impl_.e_ - impl_.b_;
  }
```

再回到core文件中，看看其中的数值：
```
(gdb)
#4  0x0000000000b83fa5 in folly::fbvector<std::shared_ptr<IOThreadConnManager>, std::allocator<std::shared_ptr<IOThreadConnManager> > >::operator[] (this=0x7f7064488160, n=19)
    at /opt/im-cloud-server-thirdparty/linux/include/folly/FBVector.h:1033
1033	    assert(n < size());
(gdb) p *this
$1 = {<boost::totally_ordered<folly::fbvector<std::shared_ptr<IOThreadConnManager>, std::allocator<std::shared_ptr<IOThreadConnManager> > >, folly::fbvector<std::shared_ptr<IOThreadConnManager>, std::allocator<std::shared_ptr<IOThreadConnManager> > >, boost::detail::empty_base<folly::fbvector<std::shared_ptr<IOThreadConnManager>, std::allocator<std::shared_ptr<IOThreadConnManager> > > >, boost::detail::false_t>> = {<boost::totally_ordered1<folly::fbvector<std::shared_ptr<IOThreadConnManager>, std::allocator<std::shared_ptr<IOThreadConnManager> > >, boost::detail::empty_base<folly::fbvector<std::shared_ptr<IOThreadConnManager>, std::allocator<std::shared_ptr<IOThreadConnManager> > > > >> = {<boost::less_than_comparable1<folly::fbvector<std::shared_ptr<IOThreadConnManager>, std::allocator<std::shared_ptr<IOThreadConnManager> > >, boost::equality_comparable1<folly::fbvector<std::shared_ptr<IOThreadConnManager>, std::allocator<std::shared_ptr<IOThreadConnManager> > >, boost::detail::empty_base<folly::fbvector<std::shared_ptr<IOThreadConnManager>, std::allocator<std::shared_ptr<IOThreadConnManager> > > > > >> = {<boost::equality_comparable1<folly::fbvector<std::shared_ptr<IOThreadConnManager>, std::allocator<std::shared_ptr<IOThreadConnManager> > >, boost::detail::empty_base<folly::fbvector<std::shared_ptr<IOThreadConnManager>, std::allocator<std::shared_ptr<IOThreadConnManager> > > > >> = {<boost::detail::empty_base<folly::fbvector<std::shared_ptr<IOThreadConnManager>, std::allocator<std::shared_ptr<IOThreadConnManager> > > >> = {<No data fields>}, <No data fields>}, <No data fields>}, <No data fields>}, <No data fields>},
  impl_ = {<std::allocator<std::shared_ptr<IOThreadConnManager> >> = {<__gnu_cxx::new_allocator<std::shared_ptr<IOThreadConnManager> >> = {<No data fields>}, <No data fields>}, b_ = 0x7f7064460d00, e_ = 0x7f7064460e00,
    z_ = 0x7f7064460e00}}
```

n = 19; size() = e_ - b_ = 0x7f7064460e00 - 0x7f7064460d00 = 256; n < size(); 不会产生越界才对，怎么会assert(n < size());

通过GDB的方式计算下size()的值：

```
(gdb) p this->impl_.e_ - this->impl_.b_
$2 = 16
```
这里涉及到C语言步长的问题，b_和为e_为shared_ptr类型的指针，步长是16，所以会出现上面的结果；


***业务上分析***
至此底层的原因已经比较清晰了，是因为AccessServer收到一个connid=81604399688的数据包，反向解析出线程ID=19，导致数组报错；
进一步排查发现是因为业务服务器的bug，导致下发的connid有问题；业务服务器误把其他AccessServer的connid发给这个服务器了，因为其他AccessServer都是24核24线程，只有这台服务器是16核16线程，所有只有这一台服务器挂；



